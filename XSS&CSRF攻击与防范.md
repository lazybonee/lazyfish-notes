### XSS攻击
**首先了解一下XSS 有哪些注入的方法：**  
1.在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。  
2.在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 
3.在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。  
4.在标签的 href、src 等属性中，包含 javascript: 等可执行代码。  
5.在 onload、onerror、onclick 等事件中，注入不受控制代码。  
6.在 style 属性和标签中，包含类似 background-image:url("javascript:..."); 的代码（新版本浏览器已经可以防范）。  
7.在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。  
总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。  

#### 存储型 XSS  
存储型 XSS 的攻击步骤：  
  
攻击者将恶意代码提交到目标网站的数据库中。  
用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。  
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。  
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  
这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

#### 反射型 XSS  
反射型 XSS 的攻击步骤：  
  
攻击者构造出特殊的 URL，其中包含恶意代码。  
用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。  
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。  
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  

**反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。**  

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。  
由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。  

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

#### DOM 型 XSS  
DOM 型 XSS 的攻击步骤：  

攻击者构造出特殊的 URL，其中包含恶意代码。  
用户打开带有恶意代码的 URL。  
用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。  
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  
**DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。**

### XSS防范  
通过前面的介绍，我们知道XSS防范主要从两方面下手：
1.防范攻击者提交恶意代码  
2.防止浏览器执行恶意代码  
针对第一点：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？  
#### 输入过滤
对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤。  
但输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类：  
1.防止 HTML 中出现注入。  
2.防止 JavaScript 执行时，执行恶意代码。  
整体的 XSS 防范是非常复杂和繁琐的，我们不仅需要在全部需要转义的位置，对数据进行对应的转义。而且要防止多余和错误的转义，避免正常的用户输入出现乱码。
虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：

**a.利用模板引擎**
开启模板引擎自带的 HTML 转义功能。例如：
在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；
在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；
在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。
**b.避免内联事件**
尽量不要使用 onLoad="onload('{{data}}')"、onClick="go('{{action}}')" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。
**c.避免拼接 HTML**
前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。
**d.时刻保持警惕**
在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。
**e.限制用户输入长度，增加攻击的难度**
**f.主动检测和发现**
可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。
**g.对Cookie使用http-only，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。**
**h.验证码：防止脚本冒充用户提交危险操作。**
